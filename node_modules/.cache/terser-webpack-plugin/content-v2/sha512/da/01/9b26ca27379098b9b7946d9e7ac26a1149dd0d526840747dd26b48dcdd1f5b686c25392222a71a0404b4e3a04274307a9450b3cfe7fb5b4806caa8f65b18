{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{650:function(_,v,t){\"use strict\";t.r(v);var a=t(5),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"http和https\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http和https\"}},[_._v(\"#\")]),_._v(\" HTTP和HTTPS\")]),_._v(\" \"),t(\"h2\",{attrs:{id:\"http\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http\"}},[_._v(\"#\")]),_._v(\" HTTP\")]),_._v(\" \"),t(\"p\",[_._v(\"HTTP是一个基于TCP/IP\"),t(\"a\",{attrs:{href:\"https://www.zhihu.com/search?q=%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A72616216%7D\",target:\"_blank\",rel:\"noopener noreferrer\"}},[_._v(\"通信协议\"),t(\"OutboundLink\")],1),_._v(\"来传递数据的协议，传输的数据类型为HTML 文件、图片文件, 查询结果等。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"http报文结构\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http报文结构\"}},[_._v(\"#\")]),_._v(\" HTTP报文结构\")]),_._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"起始行 + 头部 + 空行 + 实体\\n\")])])]),t(\"h5\",{attrs:{id:\"起始行\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#起始行\"}},[_._v(\"#\")]),_._v(\" 起始行\")]),_._v(\" \"),t(\"p\",[_._v(\"请求报文的起始行\")]),_._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"GET /home HTTP/1.1\\n\")])])]),t(\"p\",[_._v(\"方法 路径 http版本\")]),_._v(\" \"),t(\"p\",[_._v(\"对于响应报文来说，起始行一般长这样\")]),_._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"HTTP/1.1 200 OK\\n\")])])]),t(\"p\",[_._v(\"响应报文的起始行也叫做\"),t(\"code\",[_._v(\"状态行\")]),_._v(\"。由\"),t(\"strong\",[_._v(\"http版本、状态码和原因\")]),_._v(\"三部分组成。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"头部\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#头部\"}},[_._v(\"#\")]),_._v(\" 头部\")]),_._v(\" \"),t(\"p\",[_._v(\"对应请求头和响应头。\")]),_._v(\" \"),t(\"img\",{staticStyle:{zoom:\"33%\"},attrs:{src:\"https://tva1.sinaimg.cn/large/008i3skNly1gxcfjrd7joj30xs0u0ac4.jpg\"}}),_._v(\" \"),t(\"h5\",{attrs:{id:\"空行\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#空行\"}},[_._v(\"#\")]),_._v(\" 空行\")]),_._v(\" \"),t(\"p\",[_._v(\"很重要，用来区分开\"),t(\"code\",[_._v(\"头部\")]),_._v(\"和\"),t(\"code\",[_._v(\"实体\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"问: 如果说在头部中间故意加一个空行会怎么样？\")]),_._v(\" \"),t(\"p\",[_._v(\"那么空行后的内容全部被视为实体。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"实体\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实体\"}},[_._v(\"#\")]),_._v(\" 实体\")]),_._v(\" \"),t(\"p\",[_._v(\"就是具体的数据了，也就是\"),t(\"code\",[_._v(\"body\")]),_._v(\"部分。请求报文对应\"),t(\"code\",[_._v(\"请求体\")]),_._v(\", 响应报文对应\"),t(\"code\",[_._v(\"响应体\")]),_._v(\"。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"http请求方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http请求方法\"}},[_._v(\"#\")]),_._v(\" HTTP请求方法\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"GET: 通常用来获取资源\")]),_._v(\" \"),t(\"li\",[_._v(\"HEAD: 获取资源的元信息\")]),_._v(\" \"),t(\"li\",[_._v(\"POST: 提交数据，即上传数据\")]),_._v(\" \"),t(\"li\",[_._v(\"PUT: 修改数据\")]),_._v(\" \"),t(\"li\",[_._v(\"DELETE: 删除资源(几乎用不到)\")]),_._v(\" \"),t(\"li\",[_._v(\"CONNECT: 建立连接隧道，用于代理服务器\")]),_._v(\" \"),t(\"li\",[_._v(\"OPTIONS: 列出可对资源实行的请求方法，用来跨域请求\")]),_._v(\" \"),t(\"li\",[_._v(\"TRACE: 追踪请求-响应的传输路径\")])]),_._v(\" \"),t(\"h6\",{attrs:{id:\"什么是options请求？\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是options请求？\"}},[_._v(\"#\")]),_._v(\" 什么是OPTIONS请求？\")]),_._v(\" \"),t(\"p\",[t(\"a\",{attrs:{href:\"https://links.jianshu.com/go?to=%5Bhttps%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS%5D(https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS)\",target:\"_blank\",rel:\"noopener noreferrer\"}},[_._v(\"CORS MDN\"),t(\"OutboundLink\")],1),_._v(\"是这么描述的\")]),_._v(\" \"),t(\"p\",[_._v(\"跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，\"),t(\"strong\",[_._v(\"对那些可能对服务器数据产生副作用的 HTTP 请求方法\")]),_._v(\"（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），\"),t(\"strong\",[_._v(\"浏览器必须首先使用OPTIONS方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求\")]),_._v(\"。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"post和get的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#post和get的区别\"}},[_._v(\"#\")]),_._v(\" POST和GET的区别\")]),_._v(\" \"),t(\"p\",[_._v(\"首先最直观的是语义上的区别。\")]),_._v(\" \"),t(\"p\",[_._v(\"而后又有这样一些具体的差别:\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"从\"),t(\"strong\",[_._v(\"缓存\")]),_._v(\"的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。\")]),_._v(\" \"),t(\"li\",[_._v(\"从\"),t(\"strong\",[_._v(\"编码\")]),_._v(\"的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。\")]),_._v(\" \"),t(\"li\",[_._v(\"从\"),t(\"strong\",[_._v(\"参数\")]),_._v(\"的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。\")]),_._v(\" \"),t(\"li\",[_._v(\"从\"),t(\"strong\",[_._v(\"幂等性\")]),_._v(\"的角度，\"),t(\"code\",[_._v(\"GET\")]),_._v(\"是\"),t(\"strong\",[_._v(\"幂等\")]),_._v(\"的，而\"),t(\"code\",[_._v(\"POST\")]),_._v(\"不是。(\"),t(\"code\",[_._v(\"幂等\")]),_._v(\"表示执行相同的操作，结果也是相同的)\")]),_._v(\" \"),t(\"li\",[_._v(\"从\"),t(\"strong\",[_._v(\"TCP\")]),_._v(\"的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(\"),t(\"strong\",[_._v(\"火狐\")]),_._v(\"浏览器除外，它的 POST 请求只发一个 TCP 包)\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"状态码\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#状态码\"}},[_._v(\"#\")]),_._v(\" 状态码\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[_._v(\"1xx\")]),_._v(\": 表示目前是协议处理的中间状态，还需要后续操作。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"2xx\")]),_._v(\": 表示成功状态。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"3xx\")]),_._v(\": 重定向状态，资源位置发生变动，需要重新请求。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"4xx\")]),_._v(\": 请求报文有误。\")]),_._v(\" \"),t(\"li\",[t(\"strong\",[_._v(\"5xx\")]),_._v(\": 服务器端发生错误。\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"_1xx\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1xx\"}},[_._v(\"#\")]),_._v(\" 1XX\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"101 http -> ws\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"_2xx\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2xx\"}},[_._v(\"#\")]),_._v(\" 2XX\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"200 响应成功\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"_3xx\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3xx\"}},[_._v(\"#\")]),_._v(\" 3XX\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"301 永久重定向\")]),_._v(\" \"),t(\"li\",[_._v(\"302 临时重定向\")]),_._v(\" \"),t(\"li\",[_._v(\"304 协商缓存\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"_4xx\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4xx\"}},[_._v(\"#\")]),_._v(\" 4XX\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"400 前端请求错误\")]),_._v(\" \"),t(\"li\",[_._v(\"403 服务器禁止访问\")]),_._v(\" \"),t(\"li\",[_._v(\"404 资源未找到\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"_5xx\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5xx\"}},[_._v(\"#\")]),_._v(\" 5XX\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"500 服务器错误\")]),_._v(\" \"),t(\"li\",[_._v(\"502 bad Gateway\")]),_._v(\" \"),t(\"li\",[_._v(\"503 服务器忙\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"如何理解uri\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何理解uri\"}},[_._v(\"#\")]),_._v(\" 如何理解URI\")]),_._v(\" \"),t(\"p\",[t(\"strong\",[_._v(\"URI\")]),_._v(\", 全称为(Uniform Resource Identifier), 也就是\"),t(\"strong\",[_._v(\"统一资源标识符\")]),_._v(\"，它的作用很简单，就是区分互联网上不同的资源。\")]),_._v(\" \"),t(\"p\",[_._v(\"但是，它并不是我们常说的\"),t(\"code\",[_._v(\"网址\")]),_._v(\", 网址指的是\"),t(\"code\",[_._v(\"URL\")]),_._v(\", 实际上\"),t(\"code\",[_._v(\"URI\")]),_._v(\"包含了\"),t(\"code\",[_._v(\"URN\")]),_._v(\"和\"),t(\"code\",[_._v(\"URL\")]),_._v(\"两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"http特点\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http特点\"}},[_._v(\"#\")]),_._v(\" HTTP特点\")]),_._v(\" \"),t(\"p\",[_._v(\"灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。\")]),_._v(\" \"),t(\"p\",[_._v(\"可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。\")]),_._v(\" \"),t(\"p\",[_._v(\"请求-应答。也就是\"),t(\"code\",[_._v(\"一发一收\")]),_._v(\"、\"),t(\"code\",[_._v(\"有来有回\")]),_._v(\"， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演\"),t(\"strong\",[_._v(\"请求方\")]),_._v(\"的角色。\")]),_._v(\" \"),t(\"p\",[_._v(\"无状态。这里的状态是指\"),t(\"strong\",[_._v(\"通信过程的上下文信息\")]),_._v(\"，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"http-缺点\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http-缺点\"}},[_._v(\"#\")]),_._v(\" HTTP 缺点\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"无状态\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#无状态\"}},[_._v(\"#\")]),_._v(\" 无状态\")]),_._v(\" \"),t(\"p\",[_._v(\"所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的\"),t(\"strong\",[_._v(\"无状态\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。\")]),_._v(\" \"),t(\"p\",[_._v(\"但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"明文传输\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#明文传输\"}},[_._v(\"#\")]),_._v(\" 明文传输\")]),_._v(\" \"),t(\"p\",[_._v(\"即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。\")]),_._v(\" \"),t(\"p\",[_._v(\"这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。\"),t(\"code\",[_._v(\"WIFI陷阱\")]),_._v(\"就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"队头阻塞问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#队头阻塞问题\"}},[_._v(\"#\")]),_._v(\" 队头阻塞问题\")]),_._v(\" \"),t(\"p\",[_._v(\"当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的\"),t(\"strong\",[_._v(\"队头阻塞\")]),_._v(\"问题。接下来会有一小节讨论这个问题。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"accept-系列字段（接收端）\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#accept-系列字段（接收端）\"}},[_._v(\"#\")]),_._v(\" Accept 系列字段（接收端）\")]),_._v(\" \"),t(\"p\",[_._v(\"对于\"),t(\"code\",[_._v(\"Accept\")]),_._v(\"系列字段的介绍分为四个部分: \"),t(\"strong\",[_._v(\"数据格式\")]),_._v(\"、\"),t(\"strong\",[_._v(\"压缩方式\")]),_._v(\"、\"),t(\"strong\",[_._v(\"支持语言\")]),_._v(\"和\"),t(\"strong\",[_._v(\"字符集\")]),_._v(\"。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"数据格式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据格式\"}},[_._v(\"#\")]),_._v(\" 数据格式\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"Accept\")])]),_._v(\" \"),t(\"p\",[_._v(\"取值\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"text： text/html, text/plain, text/css 等\")]),_._v(\" \"),t(\"li\",[_._v(\"image: image/gif, image/jpeg, image/png 等\")]),_._v(\" \"),t(\"li\",[_._v(\"audio/video: audio/mpeg, video/mp4 等\")]),_._v(\" \"),t(\"li\",[_._v(\"application: application/json, application/javascript, application/pdf, application/octet-stream\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"压缩方式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#压缩方式\"}},[_._v(\"#\")]),_._v(\" 压缩方式\")]),_._v(\" \"),t(\"p\",[_._v(\"Accept-Encoding\")]),_._v(\" \"),t(\"p\",[_._v(\"取值\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"gzip: 当今最流行的压缩格式\")]),_._v(\" \"),t(\"li\",[_._v(\"deflate: 另外一种著名的压缩格式\")]),_._v(\" \"),t(\"li\",[_._v(\"br: 一种专门为 HTTP 发明的压缩算法\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"// 发送端\\nContent-Encoding: gzip\\n// 接收端\\nAccept-Encoding: gzip\\n\")])])]),t(\"h5\",{attrs:{id:\"支持语言\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#支持语言\"}},[_._v(\"#\")]),_._v(\" 支持语言\")]),_._v(\" \"),t(\"p\",[_._v(\"Accept-Language\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"zh-CN, zh, en 等\")])]),_._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"// 发送端\\nContent-Language: zh-CN, zh, en\\n// 接收端\\nAccept-Language: zh-CN, zh, en\\n\")])])]),t(\"h5\",{attrs:{id:\"字符集\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字符集\"}},[_._v(\"#\")]),_._v(\" 字符集\")]),_._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"// 发送端\\nContent-Type: text/html; charset=utf-8\\n// 接收端\\nAccept-Charset: charset=utf-8\\n\")])])]),t(\"h4\",{attrs:{id:\"http传输不定长数据\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http传输不定长数据\"}},[_._v(\"#\")]),_._v(\" HTTP传输不定长数据\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"定长包体\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定长包体\"}},[_._v(\"#\")]),_._v(\" 定长包体\")]),_._v(\" \"),t(\"p\",[_._v(\"发送端在传输的时候一般会带上 \"),t(\"code\",[_._v(\"Content-Length\")]),_._v(\", 来指明包体的长度。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"不定长包体\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#不定长包体\"}},[_._v(\"#\")]),_._v(\" 不定长包体\")]),_._v(\" \"),t(\"p\",[_._v(\"通过设置字段\"),t(\"code\",[_._v(\"Transfer-Encoding: chunked\")]),_._v(\"实现\")]),_._v(\" \"),t(\"p\",[_._v(\"表示分块传输数据，设置这个字段后会自动产生两个效果:\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"Content-Length 字段会被忽略\")]),_._v(\" \"),t(\"li\",[_._v(\"基于长连接持续推送动态内容\")])]),_._v(\" \"),t(\"h4\",{attrs:{id:\"http-大文件的传输\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http-大文件的传输\"}},[_._v(\"#\")]),_._v(\" HTTP 大文件的传输\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"如何支持\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何支持\"}},[_._v(\"#\")]),_._v(\" 如何支持\")]),_._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[_._v(\"Accept-Ranges: none\\n\")])])]),t(\"h3\",{attrs:{id:\"http1-1\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http1-1\"}},[_._v(\"#\")]),_._v(\" HTTP1.1\")]),_._v(\" \"),t(\"p\",[_._v(\"http1.1通过并发连接、域名分片解决了HTTP的队头阻塞问题\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"并发连接\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#并发连接\"}},[_._v(\"#\")]),_._v(\" 并发连接\")]),_._v(\" \"),t(\"p\",[_._v(\"对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。\")]),_._v(\" \"),t(\"p\",[_._v(\"但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"域名分片\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#域名分片\"}},[_._v(\"#\")]),_._v(\" 域名分片\")]),_._v(\" \"),t(\"p\",[_._v(\"一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。\")]),_._v(\" \"),t(\"p\",[_._v(\"比如 content1.sanyuan.com 、content2.sanyuan.com。\")]),_._v(\" \"),t(\"p\",[_._v(\"这样一个\"),t(\"code\",[_._v(\"sanyuan.com\")]),_._v(\"域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。\")]),_._v(\" \"),t(\"h3\",{attrs:{id:\"http-2\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http-2\"}},[_._v(\"#\")]),_._v(\" HTTP/2\")]),_._v(\" \"),t(\"p\",[_._v(\"HTTP2.0是HTTP协议自1999年HTTP1.1发布后的首个更新，主要基于SPDY协议。HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语义兼容的基础上，进一步减少了网络的延迟。实现低延迟高吞吐量。对于前端开发者而言，减少了优化工作。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"头部压缩\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#头部压缩\"}},[_._v(\"#\")]),_._v(\" 头部压缩\")]),_._v(\" \"),t(\"p\",[_._v(\"对于部分请求，请求头占用了太多的空间，使用HPACK算法来节省\")]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把\"),t(\"strong\",[_._v(\"索引\")]),_._v(\"(比如0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种\"),t(\"strong\",[_._v(\"传索引\")]),_._v(\"的方式，可以说让请求头字段得到极大程度的精简和复用。\")])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/008i3skNly1gxdy9xeqi5j30x00km40m.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"ul\",[t(\"li\",[_._v(\"其次是对于整数和字符串进行\"),t(\"strong\",[_._v(\"哈夫曼编码\")]),_._v(\"，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的\"),t(\"strong\",[_._v(\"索引序列\")]),_._v(\"，可以达到非常高的压缩率。\")])]),_._v(\" \"),t(\"h5\",{attrs:{id:\"多路复用\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多路复用\"}},[_._v(\"#\")]),_._v(\" 多路复用\")]),_._v(\" \"),t(\"h6\",{attrs:{id:\"http-队头阻塞\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http-队头阻塞\"}},[_._v(\"#\")]),_._v(\" HTTP 队头阻塞\")]),_._v(\" \"),t(\"p\",[_._v(\"我们之前讨论了 HTTP 队头阻塞的问题，其根本原因在于HTTP 基于\"),t(\"code\",[_._v(\"请求-响应\")]),_._v(\"的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。\")]),_._v(\" \"),t(\"h6\",{attrs:{id:\"二进制分帧\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二进制分帧\"}},[_._v(\"#\")]),_._v(\" 二进制分帧\")]),_._v(\" \"),t(\"p\",[_._v(\"首先，HTTP/2 认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把报文全部换成二进制格式，全部传输\"),t(\"code\",[_._v(\"01\")]),_._v(\"串，方便了机器的解析，\")]),_._v(\" \"),t(\"p\",[_._v(\"通信双方都可以给对方发送二进制帧，这种二进制帧的\"),t(\"strong\",[_._v(\"双向传输的序列\")]),_._v(\"，也叫做\"),t(\"code\",[_._v(\"流\")]),_._v(\"(Stream)。HTTP/2 用\"),t(\"code\",[_._v(\"流\")]),_._v(\"来在一个 TCP 连接上来进行多个数据帧的通信，这就是\"),t(\"strong\",[_._v(\"多路复用\")]),_._v(\"的概念。\")]),_._v(\" \"),t(\"p\",[_._v(\"首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的\"),t(\"strong\",[_._v(\"请求报文\")]),_._v(\"和\"),t(\"strong\",[_._v(\"响应报文\")])]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/008i3skNly1gxdyz7bu6hj30xa0hutaq.jpg\",alt:\"\"}})]),_._v(\" \"),t(\"h3\",{attrs:{id:\"https\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#https\"}},[_._v(\"#\")]),_._v(\" HTTPS\")]),_._v(\" \"),t(\"p\",[_._v(\"谈到\"),t(\"code\",[_._v(\"HTTPS\")]),_._v(\", 就不得不谈到与之相对的\"),t(\"code\",[_._v(\"HTTP\")]),_._v(\"。\"),t(\"code\",[_._v(\"HTTP\")]),_._v(\"的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过\"),t(\"code\",[_._v(\"WIFI路由器\")]),_._v(\"、\"),t(\"code\",[_._v(\"运营商\")]),_._v(\"和\"),t(\"code\",[_._v(\"目标服务器\")]),_._v(\"，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的\"),t(\"strong\",[_._v(\"中间人攻击\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"HTTPS\")]),_._v(\"并不是一个新的协议, 而是一个加强版的\"),t(\"code\",[_._v(\"HTTP\")]),_._v(\"。其原理是在\"),t(\"code\",[_._v(\"HTTP\")]),_._v(\"和\"),t(\"code\",[_._v(\"TCP\")]),_._v(\"之间建立了一个中间层，当\"),t(\"code\",[_._v(\"HTTP\")]),_._v(\"和\"),t(\"code\",[_._v(\"TCP\")]),_._v(\"通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给\"),t(\"code\",[_._v(\"TCP\")]),_._v(\", 响应的，\"),t(\"code\",[_._v(\"TCP\")]),_._v(\"必须将数据包解密，才能传给上面的\"),t(\"code\",[_._v(\"HTTP\")]),_._v(\"。这个中间层也叫\"),t(\"code\",[_._v(\"安全层\")]),_._v(\"。\"),t(\"code\",[_._v(\"安全层\")]),_._v(\"的核心就是对数据\"),t(\"code\",[_._v(\"加解密\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"接下来我们就来剖析一下\"),t(\"code\",[_._v(\"HTTPS\")]),_._v(\"的加解密是如何实现的。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"对称加密和非对称加密\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对称加密和非对称加密\"}},[_._v(\"#\")]),_._v(\" 对称加密和非对称加密\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"概念\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概念\"}},[_._v(\"#\")]),_._v(\" 概念\")]),_._v(\" \"),t(\"p\",[_._v(\"首先需要理解\"),t(\"code\",[_._v(\"对称加密\")]),_._v(\"和\"),t(\"code\",[_._v(\"非对称加密\")]),_._v(\"的概念，然后讨论两者应用后的效果如何。\")]),_._v(\" \"),t(\"p\",[t(\"code\",[_._v(\"对称加密\")]),_._v(\"是最简单的方式，指的是\"),t(\"code\",[_._v(\"加密\")]),_._v(\"和\"),t(\"code\",[_._v(\"解密\")]),_._v(\"用的是\"),t(\"strong\",[_._v(\"同样的密钥\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"而对于\"),t(\"code\",[_._v(\"非对称加密\")]),_._v(\"，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"加解密过程\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#加解密过程\"}},[_._v(\"#\")]),_._v(\" 加解密过程\")]),_._v(\" \"),t(\"p\",[_._v(\"接着我们来谈谈\"),t(\"code\",[_._v(\"浏览器\")]),_._v(\"和\"),t(\"code\",[_._v(\"服务器\")]),_._v(\"进行协商加解密的过程。\")]),_._v(\" \"),t(\"p\",[_._v(\"首先，浏览器会给服务器发送一个随机数\"),t(\"code\",[_._v(\"client_random\")]),_._v(\"和一个加密的方法列表。\")]),_._v(\" \"),t(\"p\",[_._v(\"服务器接收后给浏览器返回另一个随机数\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"和加密方法。\")]),_._v(\" \"),t(\"p\",[_._v(\"现在，两者拥有三样相同的凭证: \"),t(\"code\",[_._v(\"client_random\")]),_._v(\"、\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"和加密方法。\")]),_._v(\" \"),t(\"p\",[_._v(\"接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的\"),t(\"code\",[_._v(\"暗号\")]),_._v(\"。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"各自应用的效果\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#各自应用的效果\"}},[_._v(\"#\")]),_._v(\" 各自应用的效果\")]),_._v(\" \"),t(\"p\",[_._v(\"如果用\"),t(\"code\",[_._v(\"对称加密\")]),_._v(\"的方式，那么第三方可以在中间获取到\"),t(\"code\",[_._v(\"client_random\")]),_._v(\"、\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。\")]),_._v(\" \"),t(\"p\",[_._v(\"既然\"),t(\"code\",[_._v(\"对称加密\")]),_._v(\"这么不堪一击，我们就来试一试\"),t(\"code\",[_._v(\"非对称\")]),_._v(\"加密。在这种加密方式中，服务器手里有两把钥匙，一把是\"),t(\"code\",[_._v(\"公钥\")]),_._v(\"，也就是说每个人都能拿到，是公开的，另一把是\"),t(\"code\",[_._v(\"私钥\")]),_._v(\"，这把私钥只有服务器自己知道。\")]),_._v(\" \"),t(\"p\",[_._v(\"好，现在开始传输。\")]),_._v(\" \"),t(\"p\",[_._v(\"浏览器把\"),t(\"code\",[_._v(\"client_random\")]),_._v(\"和加密方法列表传过来，服务器接收到，把\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"、\"),t(\"code\",[_._v(\"加密方法\")]),_._v(\"和\"),t(\"code\",[_._v(\"公钥\")]),_._v(\"传给浏览器。\")]),_._v(\" \"),t(\"p\",[_._v(\"现在两者拥有相同的\"),t(\"code\",[_._v(\"client_random\")]),_._v(\"、\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"和加密方法。然后浏览器用公钥将\"),t(\"code\",[_._v(\"client_random\")]),_._v(\"和\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"加密，生成与服务器通信的\"),t(\"code\",[_._v(\"暗号\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"这时候由于是\"),t(\"strong\",[_._v(\"非对称加密\")]),_._v(\"，公钥加密过的数据只能用\"),t(\"code\",[_._v(\"私钥\")]),_._v(\"解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。\")]),_._v(\" \"),t(\"p\",[_._v(\"这难道一定就安全吗？聪明的小伙伴早就发现了端倪。回到\"),t(\"code\",[_._v(\"非对称加密\")]),_._v(\"的定义，公钥加密的数据可以用私钥解密，那私钥加密的数据也可以用公钥解密呀！\")]),_._v(\" \"),t(\"p\",[_._v(\"服务器的数据只能用私钥进行加密(因为如果它用公钥那么浏览器也没法解密啦)，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的，因此我们暂且不采用这种方案。\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"对称加密和非对称加密的结合\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对称加密和非对称加密的结合\"}},[_._v(\"#\")]),_._v(\" 对称加密和非对称加密的结合\")]),_._v(\" \"),t(\"p\",[_._v(\"可以发现，对称加密和非对称加密，单独应用任何一个，都会存在安全隐患。那我们能不能把两者结合，进一步保证安全呢？\")]),_._v(\" \"),t(\"p\",[_._v(\"其实是可以的，演示一下整个流程：\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"浏览器向服务器发送\"),t(\"code\",[_._v(\"client_random\")]),_._v(\"和加密方法列表。\")]),_._v(\" \"),t(\"li\",[_._v(\"服务器接收到，返回\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"、加密方法以及公钥。\")]),_._v(\" \"),t(\"li\",[_._v(\"浏览器接收，接着生成另一个随机数\"),t(\"code\",[_._v(\"pre_random\")]),_._v(\", 并且用公钥加密，传给服务器。(敲黑板！重点操作！)\")]),_._v(\" \"),t(\"li\",[_._v(\"服务器用私钥解密这个被加密后的\"),t(\"code\",[_._v(\"pre_random\")]),_._v(\"。\")])]),_._v(\" \"),t(\"p\",[_._v(\"现在浏览器和服务器有三样相同的凭证:\"),t(\"code\",[_._v(\"client_random\")]),_._v(\"、\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"和\"),t(\"code\",[_._v(\"pre_random\")]),_._v(\"。然后两者用相同的加密方法混合这三个随机数，生成最终的\"),t(\"code\",[_._v(\"密钥\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"然后浏览器和服务器尽管用一样的密钥进行通信，即使用\"),t(\"code\",[_._v(\"对称加密\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而\"),t(\"strong\",[_._v(\"拿不到pre_random\")]),_._v(\"，也就无法生成最终的密钥了。\")]),_._v(\" \"),t(\"p\",[_._v(\"回头比较一下和单纯的使用\"),t(\"strong\",[_._v(\"非对称加密\")]),_._v(\", 这种方式做了什么改进呢？本质上是\"),t(\"strong\",[_._v(\"防止了私钥加密的数据外传\")]),_._v(\"。单独使用\"),t(\"strong\",[_._v(\"非对称加密\")]),_._v(\"，最大的漏洞在于服务器传数据给浏览器只能用\"),t(\"code\",[_._v(\"私钥\")]),_._v(\"加密，这是危险产生的根源。利用\"),t(\"code\",[_._v(\"对称和非对称\")]),_._v(\"加密结合的方式，就防止了这一点，从而保证了安全。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"添加数字证书\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#添加数字证书\"}},[_._v(\"#\")]),_._v(\" 添加数字证书\")]),_._v(\" \"),t(\"p\",[_._v(\"尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。\")]),_._v(\" \"),t(\"p\",[_._v(\"事实上\"),t(\"code\",[_._v(\"HTTPS\")]),_._v(\"在上述\"),t(\"code\",[_._v(\"结合对称和非对称加密\")]),_._v(\"的基础上，又添加了\"),t(\"code\",[_._v(\"数字证书认证\")]),_._v(\"的步骤。其目的就是让服务器证明自己的身份。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"传输过程\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#传输过程\"}},[_._v(\"#\")]),_._v(\" 传输过程\")]),_._v(\" \"),t(\"p\",[_._v(\"为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫\"),t(\"code\",[_._v(\"CA\")]),_._v(\"(\"),t(\"code\",[_._v(\"Certificate Authority\")]),_._v(\"), 认证通过后 CA 会给服务器颁发\"),t(\"strong\",[_._v(\"数字证书\")]),_._v(\"。\")]),_._v(\" \"),t(\"p\",[_._v(\"这个数字证书有两个作用:\")]),_._v(\" \"),t(\"ol\",[t(\"li\",[_._v(\"服务器向浏览器证明自己的身份。\")]),_._v(\" \"),t(\"li\",[_._v(\"把公钥传给浏览器。\")])]),_._v(\" \"),t(\"p\",[_._v(\"这个验证的过程发生在什么时候呢？\")]),_._v(\" \"),t(\"p\",[_._v(\"当服务器传送\"),t(\"code\",[_._v(\"server_random\")]),_._v(\"、加密方法的时候，顺便会带上\"),t(\"code\",[_._v(\"数字证书\")]),_._v(\"(包含了\"),t(\"code\",[_._v(\"公钥\")]),_._v(\"), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。\")]),_._v(\" \"),t(\"p\",[_._v(\"现在我们来梳理一下\"),t(\"code\",[_._v(\"HTTPS\")]),_._v(\"最终的加解密过程:\")]),_._v(\" \"),t(\"h4\",{attrs:{id:\"tls握手\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tls握手\"}},[_._v(\"#\")]),_._v(\" TLS握手\")]),_._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f080a6f6375dc1~tplv-t2oaga2asx-watermark.webp\",alt:\"img\"}})]),_._v(\" \"),t(\"h5\",{attrs:{id:\"认证过程\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#认证过程\"}},[_._v(\"#\")]),_._v(\" 认证过程\")]),_._v(\" \"),t(\"p\",[_._v(\"浏览器拿到数字证书后，如何来对证书进行认证呢？\")]),_._v(\" \"),t(\"p\",[_._v(\"首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 Hash 函数，来这个函数来计算明文内容得到\"),t(\"code\",[_._v(\"信息A\")]),_._v(\"，然后用公钥解密明文内容得到\"),t(\"code\",[_._v(\"信息B\")]),_._v(\"，两份信息做比对，一致则表示认证合法。\")]),_._v(\" \"),t(\"p\",[_._v(\"当然有时候对于浏览器而言，它不知道哪些 CA 是值得信任的，因此会继续查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性。一般根级的 CA 会内置在操作系统当中，当然如果向上找没有找到根级的 CA，那么将被视为不合法。\")]),_._v(\" \"),t(\"h5\",{attrs:{id:\"总结\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[_._v(\"#\")]),_._v(\" 总结\")]),_._v(\" \"),t(\"p\",[_._v(\"HTTPS并不是一个新的协议, 它在\"),t(\"code\",[_._v(\"HTTP\")]),_._v(\"和\"),t(\"code\",[_._v(\"TCP\")]),_._v(\"的传输中建立了一个安全层，利用\"),t(\"code\",[_._v(\"对称加密\")]),_._v(\"和\"),t(\"code\",[_._v(\"非对称加密\")]),_._v(\"结合数字证书认证的方式，让传输过程的安全性大大提高。\")])])}),[],!1,null,null,null);v.default=e.exports}}]);","extractedComments":[]}