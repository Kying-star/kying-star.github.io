{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{653:function(v,_,a){\"use strict\";a.r(_);var t=a(5),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"http缓存\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http缓存\"}},[v._v(\"#\")]),v._v(\" HTTP缓存\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/008i3skNly1gwydmfqe3rj30vu0fcgmx.jpg\",alt:\"\"}})]),v._v(\" \"),a(\"h3\",{attrs:{id:\"什么是浏览器缓存？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是浏览器缓存？\"}},[v._v(\"#\")]),v._v(\" 什么是浏览器缓存？\")]),v._v(\" \"),a(\"p\",[v._v(\"浏览器缓存是指的  \"),a(\"strong\",[v._v(\"web资源的副本\")]),v._v(\" 。\")]),v._v(\" \"),a(\"p\",[v._v(\"当浏览器向服务器请求资源时，若是相同的url，浏览器会根据缓存机制决定是使用副本来响应访问请求，还是向源服务器再次发送请求。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"为什么需要浏览器缓存-？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么需要浏览器缓存-？\"}},[v._v(\"#\")]),v._v(\" 为什么需要浏览器缓存 ？\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"减少网络延迟，加快页面打开速度\")]),v._v(\" \"),a(\"li\",[v._v(\"减少网络带宽消耗\")]),v._v(\" \"),a(\"li\",[v._v(\"降低服务压力\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"http缓存机制\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http缓存机制\"}},[v._v(\"#\")]),v._v(\" HTTP缓存机制\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"简化流程如下\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#简化流程如下\"}},[v._v(\"#\")]),v._v(\" 简化流程如下\")]),v._v(\" \"),a(\"img\",{staticStyle:{zoom:\"75%\"},attrs:{src:\"https://tva1.sinaimg.cn/large/008i3skNgy1gvv5o8vut1j30jj0d6q38.jpg\"}}),v._v(\" \"),a(\"h4\",{attrs:{id:\"缓存规则\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#缓存规则\"}},[v._v(\"#\")]),v._v(\" 缓存规则\")]),v._v(\" \"),a(\"p\",[v._v(\"1、新鲜度(过期机制):一个缓存副本的有效期。一个缓存副本满足以下性质时，我们认为他是新鲜的\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"含有完整的过期时间控制头信息(HTTP协议报头)，并且仍在有效期内；\")]),v._v(\" \"),a(\"li\",[v._v(\"浏览器已经使用过这个副本，并且在一个会话中已经检查过新鲜度；\")])]),v._v(\" \"),a(\"p\",[v._v(\"2、校验值(验证机制):服务器返回资源的时候。有时会在控制头信息带上这个资源的实体标签Etag,他可以用来作为浏览器再次请求过程的校验标志。如果发现校验标志不匹配，说明资源已经被修改或过期，浏览器就会重新获取资源内容。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"http缓存的两个阶段\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http缓存的两个阶段\"}},[v._v(\"#\")]),v._v(\" HTTP缓存的两个阶段\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"强缓存(本地缓存)\")]),v._v(\" \"),a(\"li\",[v._v(\"弱缓存(协商缓存)\")])]),v._v(\" \"),a(\"h4\",{attrs:{id:\"强缓存\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#强缓存\"}},[v._v(\"#\")]),v._v(\" 强缓存\")]),v._v(\" \"),a(\"p\",[v._v(\"浏览器发送请求前，会先去缓存里查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器。否则，就会进入协商缓存阶段。\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"弱缓存-协商缓存\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#弱缓存-协商缓存\"}},[v._v(\"#\")]),v._v(\" 弱缓存(协商缓存)\")]),v._v(\" \"),a(\"p\",[v._v(\"当强缓存没有命中的时，浏览器会向服务器发起请求。服务器会根据请求头中携带的字段；来判断是否命中协商缓存。如果命中，服务器会下发304响应（不携带任何实体信息），告诉服务器可以直接从浏览器缓存中获取这个信息。但是如果强弱缓存都没有命中的话，就会直接从服务器加载资源。\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"启用-关闭缓存\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#启用-关闭缓存\"}},[v._v(\"#\")]),v._v(\" 启用&关闭缓存\")]),v._v(\" \"),a(\"p\",[v._v(\"按照本地缓存和协商缓存可以将控制缓存的方式分为\")]),v._v(\" \"),a(\"img\",{staticStyle:{zoom:\"50%\"},attrs:{src:\"https://tva1.sinaimg.cn/large/008i3skNgy1gwbcjeoqzjj30t90hnjs1.jpg\"}}),v._v(\" \"),a(\"h4\",{attrs:{id:\"强缓存过程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#强缓存过程\"}},[v._v(\"#\")]),v._v(\" 强缓存过程\")]),v._v(\" \"),a(\"p\",[v._v(\"浏览器中的缓存分为两种情况\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"需要发送http请求\")]),v._v(\" \"),a(\"li\",[v._v(\"不需要发送http请求\")])]),v._v(\" \"),a(\"p\",[v._v(\"首先是检查本地强缓存,这个阶段不需要进行http请求\")]),v._v(\" \"),a(\"p\",[v._v(\"浏览器会检查http中的字段，\")]),v._v(\" \"),a(\"p\",[v._v(\"在HTTP/1.0中使用\"),a(\"code\",[v._v(\"Expires\")]),v._v(\"字段\")]),v._v(\" \"),a(\"p\",[v._v(\"在HTTP/1.1中使用\"),a(\"code\",[v._v(\"Cache-Control\")]),v._v(\"字段\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"expires\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#expires\"}},[v._v(\"#\")]),v._v(\" Expires\")]),v._v(\" \"),a(\"p\",[v._v(\"过期时间，存在服务端返回的响应头里，告诉浏览器在这个过期时间内可以直接从缓存里面获取数据。\")]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[v._v(\"Expires: Wed, 22 Nov 2019 08:41:00 GMT\\n\")])])]),a(\"p\",[v._v(\"但是这个方法存在问题，就是浏览器的时间可能跟服务器的时间不一致(时区)，所以时间可能不准确，所以在后面的HTTP/1.1中被放弃使用（但是还存在）。\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"cache-control\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cache-control\"}},[v._v(\"#\")]),v._v(\" cache-control\")]),v._v(\" \"),a(\"p\",[v._v(\"他有许多的字段在操控缓存\")]),v._v(\" \"),a(\"p\",[v._v(\"比如不再使用具体的过期时间点,采用过期时长来控制缓存，对应的字段为\"),a(\"code\",[v._v(\"max-age\")])]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[v._v(\"Cache-Control:max-age=3600\\n\")])])]),a(\"p\",[v._v(\"这个代表3600s之内，可以直接直接使用缓存。\")]),v._v(\" \"),a(\"p\",[v._v(\"除此之外他还有更多灵活的配置，\")]),v._v(\" \"),a(\"p\",[a(\"code\",[v._v(\"private:\")]),v._v(\"只有浏览器可以缓存。中间经过的代理服务器不可以缓存。\")]),v._v(\" \"),a(\"p\",[a(\"code\",[v._v(\"no-cache:\")]),v._v(\"不进行本地的缓存，直接进入协商缓存。\")]),v._v(\" \"),a(\"p\",[a(\"code\",[v._v(\"no-store:\")]),v._v(\"不进行任何形式的缓存。每一次都从浏览器获取。\")]),v._v(\" \"),a(\"p\",[a(\"code\",[v._v(\"s-maxage:\")]),v._v(\"针对代理服务器的缓存。\")]),v._v(\" \"),a(\"p\",[v._v(\"这时候如果设置的缓存时间超时，就会进入协商缓存。\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"协商缓存过程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#协商缓存过程\"}},[v._v(\"#\")]),v._v(\" 协商缓存过程\")]),v._v(\" \"),a(\"p\",[v._v(\"强缓存失败后，浏览器会在请求中携带\"),a(\"code\",[v._v(\"缓存tag\")]),v._v(\"来向服务器发送请求，由服务器根据这个tag来决定是否使用缓存，这就是协商缓存。\")]),v._v(\" \"),a(\"p\",[a(\"strong\",[v._v(\"缓存tag\")]),v._v(\"分为两种:\"),a(\"code\",[v._v(\"Last-Modified\")]),v._v(\"和\"),a(\"code\",[v._v(\"ETag\")]),v._v(\"。\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"last-modified\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#last-modified\"}},[v._v(\"#\")]),v._v(\" Last-Modified\")]),v._v(\" \"),a(\"p\",[v._v(\"最后修改时间，在浏览器向服务器发送请求后，服务器会在响应头中加上这个字段。\")]),v._v(\" \"),a(\"p\",[v._v(\"浏览器接收到后，如果再次请求，就会在请求头中携带\"),a(\"code\",[v._v(\"IF-Modified-Since\")]),v._v(\"字段，这个字段的值也就是服务器传来的最后修改时间。\")]),v._v(\" \"),a(\"p\",[v._v(\"服务器在拿到\"),a(\"code\",[v._v(\"IF-Modified-Since\")]),v._v(\"字段后,会和服务器内的\"),a(\"code\",[v._v(\"该资源的最后修改时间做对比\")]),v._v(\"(因为资源的源代码是在服务器上的，开发者修改资源的内容的时间就是该时间)\")]),v._v(\" \"),a(\"p\",[v._v(\"如果浏览器发来的\"),a(\"code\",[v._v(\"IF-Modified-Since\")]),v._v(\"的时间小于服务器中。就说明资源需要更新,就会走正常的HTTP响应请求。\")]),v._v(\" \"),a(\"p\",[v._v(\"否则返回304，告诉浏览器直接是用缓存。\")]),v._v(\" \"),a(\"h5\",{attrs:{id:\"etag\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#etag\"}},[v._v(\"#\")]),v._v(\" ETag\")]),v._v(\" \"),a(\"p\",[a(\"code\",[v._v(\"ETag\")]),v._v(\"是服务器根据当前文件的内容，给文件生成一个唯一的标识，只要里面的内容改动，这个值就会改变。同时服务器会通过\"),a(\"code\",[v._v(\"响应头\")]),v._v(\"把这个值给服务器。\")]),v._v(\" \"),a(\"img\",{staticStyle:{zoom:\"50%\"},attrs:{src:\"https://tva1.sinaimg.cn/large/008i3skNly1gwpd1f199rj30i401a3yf.jpg\"}}),v._v(\" \"),a(\"p\",[v._v(\"浏览器接收到\"),a(\"code\",[v._v(\"ETag\")]),v._v(\"的值后，会在下一次请求时，将这个值作为\"),a(\"code\",[v._v(\"if-None-Match\")]),v._v(\"这个字段的内容，并放到请求头中，然后发给服务器。\")]),v._v(\" \"),a(\"p\",[v._v(\"服务器接受到\"),a(\"code\",[v._v(\"if-None-Match\")]),v._v(\"值后，会跟服务器上该资源的\"),a(\"code\",[v._v(\"ETag\")]),v._v(\"进行比较：\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"不一样，就更新\")]),v._v(\" \"),a(\"li\",[v._v(\"一样，就304，告诉浏览器直接用缓存。\")])]),v._v(\" \"),a(\"h5\",{attrs:{id:\"两者对比\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#两者对比\"}},[v._v(\"#\")]),v._v(\" 两者对比\")]),v._v(\" \"),a(\"p\",[v._v(\"1、在\"),a(\"code\",[v._v(\"精准度\")]),v._v(\"上，\"),a(\"code\",[v._v(\"ETag\")]),v._v(\"优于\"),a(\"code\",[v._v(\"Last-Modified\")]),v._v(\"。因为ETag是和内容密切相关的，但是Last-modified并不能准确的感知资源的变化，主要有两种情况。\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"编辑了资源文件，但是文件的内容没有更改，这样也会造成缓存失败。\")]),v._v(\" \"),a(\"li\",[v._v(\"last-modified感知的时间单位是秒，文件在1秒内改变了多次，那这个时候last-modified就不能体现出来修改了\")])]),v._v(\" \"),a(\"p\",[v._v(\"2、\"),a(\"code\",[v._v(\"性能上\")]),v._v(\"last-modified优于ETag，因为ETag还需要计算资源的hash（哈希）。\")]),v._v(\" \"),a(\"p\",[v._v(\"值得注意的是，两种方式都支持的话，服务器会优先考虑ETag\")]),v._v(\" \"),a(\"h4\",{attrs:{id:\"缓存的位置\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#缓存的位置\"}},[v._v(\"#\")]),v._v(\" 缓存的位置\")]),v._v(\" \"),a(\"p\",[v._v(\"当命中\"),a(\"code\",[v._v(\"强缓存\")]),v._v(\"命中或者协商缓存中服务器返回304时，我们会直接从缓存中获取资源。\")]),v._v(\" \"),a(\"p\",[v._v(\"浏览器中的缓存位置一共有四种，按优先级从高到低可以分为\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"Service Worker\")]),v._v(\" \"),a(\"li\",[v._v(\"Memory Cache\")]),v._v(\" \"),a(\"li\",[v._v(\"Disk Cache\")]),v._v(\" \"),a(\"li\",[v._v(\"Push Cache\")])]),v._v(\" \"),a(\"h5\",{attrs:{id:\"service-worker\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#service-worker\"}},[v._v(\"#\")]),v._v(\" Service Worker\")]),v._v(\" \"),a(\"p\",[v._v(\"Service Worker借鉴了Web worker的思路，既让JS运行在主线程之外，由于他脱离了浏览器的窗体，因此无法访问DOM。虽然如此，但是他仍能帮我们完成很多有用的功能，比如\"),a(\"code\",[v._v(\"离线缓存\")]),v._v(\"、\"),a(\"code\",[v._v(\"消息推送\")]),v._v(\"、\"),a(\"code\",[v._v(\"网络代理\")]),v._v(\"。其中离线缓存就是\"),a(\"code\",[v._v(\"service Worker Cache\")]),v._v(\"。\")]),v._v(\" \"),a(\"p\",[v._v(\"Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。\")]),v._v(\" \"),a(\"blockquote\",[a(\"p\",[v._v(\"PWA(渐进式web应用)\")])]),v._v(\" \"),a(\"h5\",{attrs:{id:\"memory-cache-和-disk-cache\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#memory-cache-和-disk-cache\"}},[v._v(\"#\")]),v._v(\" Memory Cache 和 Disk Cache\")]),v._v(\" \"),a(\"p\",[v._v(\"Memory Cache指的是内存缓存。当渲染进程结束之后，内存缓存就会被清除。\")]),v._v(\" \"),a(\"p\",[v._v(\"Disk Cache 指的是磁盘缓存。储存效率比内存缓存低，但是容量大和缓存时间长。\")]),v._v(\" \"),a(\"p\",[v._v(\"浏览器的缓存策略:\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"内存大的JS文件、css文件会直接被丢入磁盘。\")]),v._v(\" \"),a(\"li\",[v._v(\"内存使用率较高时，文件优先进入磁盘。\")])]),v._v(\" \"),a(\"h5\",{attrs:{id:\"push-cache\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#push-cache\"}},[v._v(\"#\")]),v._v(\" Push Cache\")]),v._v(\" \"),a(\"p\",[v._v(\"Push Cache (推送缓存)是HTTP/2中的内容，当以上三种缓存都没有命中时，他才会被使用，他只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂。在google中只存在5分钟。\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差\")]),v._v(\" \"),a(\"li\",[v._v(\"可以推送 no-cache 和 no-store 的资源\")]),v._v(\" \"),a(\"li\",[v._v(\"一旦连接被关闭，Push Cache 就被释放\")]),v._v(\" \"),a(\"li\",[v._v(\"多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。\")]),v._v(\" \"),a(\"li\",[v._v(\"Push Cache 中的缓存只能被使用一次\")]),v._v(\" \"),a(\"li\",[v._v(\"浏览器可以拒绝接受已经存在的资源推送\")]),v._v(\" \"),a(\"li\",[v._v(\"你可以给其他域名推送资源\")])]),v._v(\" \"),a(\"p\",[v._v(\"如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。\")]),v._v(\" \"),a(\"h1\",{attrs:{id:\"ref\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ref\"}},[v._v(\"#\")]),v._v(\" ref\")]),v._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://hddhyq.github.io/2020/04/26/browser-cache-control/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v._v(\"浏览器缓存详解\"),a(\"OutboundLink\")],1)])])}),[],!1,null,null,null);_.default=e.exports}}]);","extractedComments":[]}