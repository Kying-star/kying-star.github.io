{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{670:function(a,t,e){\"use strict\";e.r(t);var r=e(5),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"monorepo\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#monorepo\"}},[a._v(\"#\")]),a._v(\" Monorepo\")]),a._v(\" \"),e(\"h4\",{attrs:{id:\"monorepo-一种项目管理方案-多个项目放在同一个文件夹下面\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#monorepo-一种项目管理方案-多个项目放在同一个文件夹下面\"}},[a._v(\"#\")]),a._v(\" Monorepo (一种项目管理方案:多个项目放在同一个文件夹下面)\")]),a._v(\" \"),e(\"img\",{staticStyle:{zoom:\"50%\"},attrs:{src:\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75a56317bdf94794a8b29f6cd184c888~tplv-k3u1fbpfcp-watermark.awebp\"}}),a._v(\" \"),e(\"h5\",{attrs:{id:\"multi-repository-将项目分文件夹管理-的缺点\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#multi-repository-将项目分文件夹管理-的缺点\"}},[a._v(\"#\")]),a._v(\" Multi Repository(将项目分文件夹管理)的缺点:\")]),a._v(\" \"),e(\"p\",[a._v(\"1、代码难以复用  - 获取某一个工具库需要下载那个依赖的包，但如果依赖的代码出错，就需要修改依赖源头的代码，然后在上传到npm上，然后再在本项目重新拉取那个包的依赖。这样的流程过于麻烦了。\")]),a._v(\" \"),e(\"p\",[a._v(\"2、版本的管理 : 依赖的升级困难，如果多个项目都需要使用某一个包，这个包的依赖版本升级时，所有依赖于这个包的项目都需要做对应的更新。\")]),a._v(\" \"),e(\"p\",[a._v(\"3、项目的基建 : 组织下的多个项目无法做归一化的流程管理，会加大项目管理的复杂度，难以维护。\")]),a._v(\" \"),e(\"h2\",{attrs:{id:\"monorepo-的好处\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#monorepo-的好处\"}},[a._v(\"#\")]),a._v(\" Monorepo 的好处:\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"工作流的一致性\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#工作流的一致性\"}},[a._v(\"#\")]),a._v(\" 工作流的一致性\")]),a._v(\" \"),e(\"p\",[a._v(\"所有的项目放在一个仓库当中，复用起来非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到。并且所有的项目都是使用最新的代码，不会产生其它项目版本更新不及时的情况。\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"项目基建成本的降低\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#项目基建成本的降低\"}},[a._v(\"#\")]),a._v(\" 项目基建成本的降低\")]),a._v(\" \"),e(\"p\",[a._v(\"所有项目复用一套标准的工具和规范，无需切换开发环境，如果有新的项目接入，也可以直接复用已有的基建流程，比如 CI 流程、构建和发布流程。这样只需要很少的人来维护所有项目的基建，维护成本也大大减低。\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"团队协作也更加容易\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#团队协作也更加容易\"}},[a._v(\"#\")]),a._v(\" 团队协作也更加容易\")]),a._v(\" \"),e(\"p\",[a._v(\"大家都在一个仓库开发，能够方便地共享和复用代码，方便检索项目源码，另一方面，git commit 的历史记录也支持以功能为单位进行提交，之前对于某个功能的提交，需要改好几个仓库，提交多个 commit，现在只需要提交一次，简化了 commit 记录，方便协作。\")]),a._v(\" \"),e(\"h2\",{attrs:{id:\"monorepo-的缺点\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#monorepo-的缺点\"}},[a._v(\"#\")]),a._v(\" monorepo 的缺点\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"多个子仓库之间的依赖冲突\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多个子仓库之间的依赖冲突\"}},[a._v(\"#\")]),a._v(\" 多个子仓库之间的依赖冲突\")]),a._v(\" \"),e(\"p\",[a._v(\"各个包之间都存在各自的依赖，有些依赖可能是多个包都需要的，我们肯定是希望相同的依赖能提升到 root 目录下安装，其它的依赖装哪都行。\")]),a._v(\" \"),e(\"p\",[a._v(\"此时我们可以通过 yarn 来解决问题（npm 7 之前不行），需要在 package.json 中加上 workspaces 字段表明多包目录，通常为 packages。\")]),a._v(\" \"),e(\"p\",[a._v(\"之后当我们安装依赖的时候，yarn 会尽量把依赖拍平装在根目录下，存在版本不同情况的时候会把使用最多的版本安装在根目录下，其它的就装在各自目录里。\")]),a._v(\" \"),e(\"p\",[a._v(\"这种看似正确的做法，可能又会带来更恶心的问题。\")]),a._v(\" \"),e(\"p\",[a._v(\"比如说多个 package 都依赖了 React，但是它们版本并不都相同。此时 node_modules 里可能就会存在这种情况：根目录下存在这个 React 的一个版本，包的目录中又存在另一个依赖的版本。\")]),a._v(\" \"),e(\"p\",[a._v(\"因为 node 寻找包的时候都是从最近目录开始寻找的，此时在开发的过程中可能就会出现多个 React 实例的问题，熟悉 React 开发的读者肯定知道这就会报错了。\")]),a._v(\" \"),e(\"p\",[a._v(\"遇到这种情况的时候，我们就得用 resolutions 去解决问题，当然也可以通过阻止 yarn 提升共同依赖来解决（更麻烦了）。笔者已经不止一次遇到过这种问题，多是安装依赖的依赖造成的多版本问题。\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"link\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#link\"}},[a._v(\"#\")]),a._v(\" link\")]),a._v(\" \"),e(\"p\",[a._v(\"在 multi repo 中各种 link 已经够头疼了，我可不想在 mono repo 中继续 link 了。\")]),a._v(\" \"),e(\"p\",[a._v(\"此时 yarn 又拯救了我们，在安装依赖的时候会帮助我们将各个 package 软链到根目录中，这样每个 package 就能找到另外的 package 以及依赖了。\")]),a._v(\" \"),e(\"p\",[a._v(\"但是实际上这样的方式还会带来一个坑。因为各个 package 都能访问到拍平在根目录中的依赖了，因此此时其实我们无需在 package.json 中声明 dependencies 就能使用别人的依赖了。这种情况很可能会造成我们最终忘了加上 dependencies，一旦部署上线项目就运行不起来了。\")]),a._v(\" \"),e(\"p\",[a._v(\"以上两块主要聊了依赖以及 link 层面的问题，这部分我们可以直接通过 yarn 解决，虽然又引入了别的问题。\")]),a._v(\" \"),e(\"h3\",{attrs:{id:\"构建\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#构建\"}},[a._v(\"#\")]),a._v(\" 构建\")]),a._v(\" \"),e(\"p\",[a._v(\"构建是我们会遇到的第一个问题。这时候可能有些读者就会说了，构建不就是跑个 build 么，能有个啥问题。哎，接下来我就跟你聊聊这些问题。\")]),a._v(\" \"),e(\"p\",[a._v(\"首先因为所有包都存在一个仓库中了，如果每次执行 CI 的时候把所有包都构建一遍，那么一旦代码量变多，每次构建可能都要花上不少的时间。\")]),a._v(\" \"),e(\"p\",[a._v(\"这时候肯定有读者会想到增量构建，每次只构建修改了代码的 package，这个确实能够解决问题，核心代码也很简单：\")]),a._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[a._v(\"git diff --name-only {git tag / commit sha} --{package path}\\n\")])])]),e(\"p\",[a._v(\"上述命令的功能是寻找从上次的 git tag 或者初次的 commit 信息中查找某个包是否存在文件变更，然后我们拿到这些信息只针对变更的包做构建就行。但是注意这个命令的前提是在部署的时候打上 tag，否则就找不到上次部署的节点了。\")]),a._v(\" \"),e(\"p\",[a._v(\"但是单纯这样的做法是不够的，因为在 mono repo 中我们还会遇到多个 package 之间有依赖的场景\")]),a._v(\" \"),e(\"p\",[a._v(\"在这种情况下假如此时在 CI 中发现只有 A 包需要构建并且只去构建了 A 包，那么就会出现问题：在 TS 环境下肯定会报错找不到 D 包的类型。\")]),a._v(\" \"),e(\"p\",[a._v(\"在这种存在包于包之间有依赖的场景时，我们需要去构建一个有向无环图（DAG）来进行拓扑排序，关于这个概念有兴趣的读者可以自行查阅资料。\")]),a._v(\" \"),e(\"p\",[a._v(\"总之在这种场景下，我们需要寻找出各个包之间的依赖关系，然后根据这个关系去构建。比如说 A 包依赖了 D 包，当我们在构建 A 包之前得先去构建 D 包才成。\")]),a._v(\" \"),e(\"p\",[a._v(\"以上是没有工具链时可能会出现的问题。如果我们用上 lerna 的话，内置的一些命令就可以基本帮助我们解决问题了：\")]),a._v(\" \"),e(\"ul\",[e(\"li\",[a._v(\"lerna changed 寻找代码有变动的包，接下来我们就可以自己去进行增量构建了。\")]),a._v(\" \"),e(\"li\",[a._v(\"通过 lerna 执行命令，本身就会去进行拓扑排序，所以包之间存在依赖时的构建问题也就被解决了。\\n总结一下构建时我们会遇到的问题：\")])]),a._v(\" \"),e(\"h3\",{attrs:{id:\"单测\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#单测\"}},[a._v(\"#\")]),a._v(\" 单测\")]),a._v(\" \"),e(\"p\",[a._v(\"单测的问题其实和构建遇到的问题类似。每次把所有用例都跑一遍，可能耗时比构建还长，引入增量单测很有必要。\")]),a._v(\" \"),e(\"p\",[a._v(\"这个需求一般来说单测工具都会提供，比如 Jest 通过以下命令我们就能实现需求了：\")]),a._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[a._v(\"jest --coverage --changedSince=master\\n\")])])]),e(\"p\",[a._v(\"但是这种单测方式会引来一个小问题：单测覆盖率是以「测试用例覆盖的代码 / 修改过的代码」来算的，很可能会出现覆盖率不达标的问题，虽然整体的单测覆盖率可能是达标的。 常写单测的读者肯定知道有时候一部分代码就是很难写单测，出现这种问题也在所难免，但是如果我们在 CI 中配置了低于覆盖率就不能通过 CI 的话就会有点蛋疼。\")]),a._v(\" \"),e(\"p\",[a._v(\"当然这个问题其实仁者见仁智者见智，往好了说也是在提高每次 commit 的代码质量。\")]),a._v(\" \"),e(\"h2\",{attrs:{id:\"部署\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#部署\"}},[a._v(\"#\")]),a._v(\" 部署\")]),a._v(\" \"),e(\"p\",[a._v(\"部署是最重要的一环了，这里会遇到的问题也是最复杂的，当然大部分问题其实之前都解决过了，问题大致可分为：\")]),a._v(\" \"),e(\"p\",[a._v(\"如何给单个 package 部署？\\n单个 package 部署时有依赖关系如何解决？\\npackage 部署时版本如何自动计算？\\n首先来看前两个问题。\")]),a._v(\" \"),e(\"p\",[a._v(\"第一个问题的解决办法其实和增量构建那边做法一样，通过命令找到修改过代码的 package 就行。但是光找到需要部署的 package 还不够，我们还需要通过拓扑排序看看这个 package 有没有被别的 package 所依赖。如果被别的 package 所依赖的话，依赖方即使代码没有变动也是需要进行部署的，这就是第二个问题的解决方案。\")]),a._v(\" \"),e(\"p\",[a._v(\"第三个问题解决起来涉及的东西会有点多，笔者之前也给自动化部署系统写过一篇文章：链接 ，有兴趣的读者可以一读。\")]),a._v(\" \"),e(\"h2\",{attrs:{id:\"工具链带来的好处及坏处\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#工具链带来的好处及坏处\"}},[a._v(\"#\")]),a._v(\" 工具链带来的好处及坏处\")]),a._v(\" \"),e(\"p\",[a._v(\"从上文中读者们应该也可以发现这些 monorepo 的工具链帮助我们解决了很多问题，以至于把这些问题都隐藏了起来，导致了很多开发者可能都不了解使用 monorepo 到底会带来哪些问题。\")]),a._v(\" \"),e(\"p\",[a._v(\"另外这些工具链也并不是完美的，使用它们以后其实又会带来一些别的问题。\")]),a._v(\" \"),e(\"p\",[a._v(\"比如说我们用 yarn workspaces 解决了 link 以及安装依赖的问题，但是又带来了版本间的冲突以及非法访问依赖的问题，解决这些问题我们可能又得引入新的包管理器，比如 pnpm 来解决。\")]),a._v(\" \"),e(\"p\",[a._v(\"总的来说，在编程世界里还真的没啥银弹，看似不错的工具，在帮助我们解决了不少问题的同时必然又会引入新的问题，选择工具无非是在看当下哪个使用起来成本更低收益更大罢了。\")]),a._v(\" \"),e(\"h2\",{attrs:{id:\"ref\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ref\"}},[a._v(\"#\")]),a._v(\" ref\")]),a._v(\" \"),e(\"p\",[e(\"a\",{attrs:{href:\"https://juejin.cn/post/6944877410827370504#heading-5\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a._v(\"现代前端工程为什么越来越离不开 Monorepo?\"),e(\"OutboundLink\")],1),a._v(\" \"),e(\"a\",{attrs:{href:\"https://segmentfault.com/a/1190000039814987\",target:\"_blank\",rel:\"noopener noreferrer\"}},[a._v(\"开源项目都在用 monorepo，但是你知道居然有那么多坑么？\"),e(\"OutboundLink\")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);","extractedComments":[]}