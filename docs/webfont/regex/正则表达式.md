
## 正则表达式

第一种通过`new RegExp`建立

```javascript
regexp = new RegExp("pattern", "flags");
```

第二种通过斜杠 `"/"`建立

```javascript
regexp = /pattern/; // 没有修饰符
regexp = /pattern/gmi; // 伴随修饰符 g、m 和 i（后面会讲到）
```
## 正则表达式的组成

- 正则表达式由四部分组成
  1. 定界符
  2. 元字符
  3. 量词
  4. 模式修饰符

### 定界符

一般用两个斜线 //，也可以用两个井号## 

> 本文全部使用 // 定界符

### 元字符

**指的是想要筛选的内容**
例如 /e/就表示要筛选e这个字母

除了使用一个字母表示要筛选的字符外，正则表达式还提供了一些特殊符号表示筛选范围中的一个

### 量词

默认情况下正则表达式采用的贪婪模式，即尽可能多的匹配
**量词表示元字符的数量，也就是筛选内容的长度**

### 模式修正（修饰）符

**模式修正符是对正则表达式进行模式修饰，写在正则表达式的定界符后边**
例如 /a/i 可以匹配大写和小写的a

------



## 模式（Patterns）和修饰符（flags）



### 修饰符

> 正则表达式的修饰符可能会影响搜索结果。

在 JavaScript 中，有 5 个修饰符：

- `i`

  使用此修饰符后，搜索时不区分大小写: `A` 和 `a` 没有区别。

- `g`

  使用此修饰符后，搜索时会查找所有的匹配项，而不只是第一个。

- `m`

  多行模式(\n)。

- `u`

  开启完整的 unicode 支持。该修饰符能够修正对于代理对的处理。

- `y`

  粘滞模式:类似与g修饰符，但要求被匹配的字符串中都相连，也就是说每次匹配严格从子串第一个字符开始。

------



#### “i”修饰符

```javascript
//代码示例
let str = "I love JavaScript!";

alert( str.search(/LOVE/) ); // -1（没找到）
alert( str.search(/LOVE/i) ); // 2
```

> `i`修饰符会将使字符匹配不区分大小写



#### “g”修饰符

```javascript
//代码示例
let str = "+7(903)-123-45-67";
let regexp = /\d/g;

alert( str.match(regexp) ); // array of matches: 7,9,0,3,1,2,3,4,5,6,7
```

> `g`修饰符会匹配到所有的符合字符

#### “m”修饰符

```javascript
//代码示例
let str = `1st place: Winnie
2nd place: Piglet
33rd place: Eeyore`;

alert( str.match(/^\d+/gm) ); // 1, 2, 33
```

> `m`修饰符会匹配多行文本中的符合字符

#### “u”修饰符

```javascript
//代码实例
let regexp = /\p{Sc}\d/gu;

let  str = `Prices: $2, €1, ¥9`;

alert( str.match(regexp) ); // $2,€1,¥9
```

> 修饰符 `u` 在正则表达式中提供对 Unicode 的支持。

#### "y"修饰符

```javascript
//代码示例
let s = 'aaa_aa_a';
let r1 = /a+/g;
let r2 = /a+/y;
r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]
r1.exec(s) // ["aa"]
r2.exec(s) // null
```

> `y`修饰符的作用与`g`修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，`g`修饰符只要剩余位置中存在匹配就可，而`y`修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。



> 上面代码有两个正则表达式，一个使用`g`修饰符，另一个使用`y`修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是`_aa_a`。由于`g`修饰没有位置要求，所以第二次执行会返回结果，而`y`修饰符要求匹配必须从头部开始，所以返回`null`。





## 书写正则表达式



### 锚点（Anchors)：字符串开始 ^ 和末尾 $

>插入符号 `^` 和美元符号 `$` 在正则表达式中具有特殊的意义。
>
>它们被称为“锚点”。
>
>插入符号 `^` 匹配文本开头，
>
>而美元符号 `$` － 则匹配文本末尾。



举个:chestnut:子

`^`

```javascript
let str1 = "Mary had a little lamb";
alert( /^Mary/.test(str1) ); // true
//从头开始匹配
```

`$`

```javascript
let str1 = "it's fleece was white as snow";
alert( /snow$/.test(str1) ); // true
//从尾开始匹配
```

### 集合和范围 [...]

在方括号 `[…]` 中的几个字符或者字符类意味着“搜索给定的字符中的任意一个”。

#### 集合



- 比如说，`[eao]` 意味着查找在 3 个字符 `'a'`、`'e'` 或者 `‘o’ `中的任意一个。

这被叫做一个**集合**。集合可以在正则表达式中和其它常规字符一起使用。



```javascript
// 查找 [t 或者 m]，然后再匹配 “op”
alert( "Mop top".match(/[tm]op/gi) ); // "Mop", "top"
```

> 注意尽管在集合中有多个字符，但它们在匹配中只会对应其中的一个

```javascript
// 查找 “V”，然后匹配 [o 或者 i]，之后再匹配 “la”
alert( "Voila".match(/V[oi]la/) ); // null，并没有匹配上
```

#### 范围

- 方括号也可以包含**字符范围**。

  比如说，`[a-z]` 会匹配从 `a` 到 `z` 范围内的字母，`[0-5]` 表示从 `0` 到 `5` 的数字。

  在下面的示例中，我们会查询首先匹配 `"x"` 字符，再匹配两个数字或者位于 `A` 到 `F` 范围内的字符。

```javascript
alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF
```

>`[0-9A-F]` 表示两个范围：它搜索一个字符，满足数字 `0` 到 `9` 或字母 `A` 到 `F`。
>
> 如果我们还想查找小写字母，则可以添加范围 `a-f`：`[0-9A-Fa-f]`。或添加标志 `i`。 
>
>我们也可以在 `[…]` 里面使用字符类。 例如，如果我们想要查找单词字符 `\w` 或连字符 `-`，则该集合为 `[\w-]`。
>
> 也可以组合多个类，例如 `[\s\d]` 表示 “空格字符或数字”。





### 常用元字符

`\w`    ===> <b style="color:orange">同 [a-zA-Z0-9_]</b>     *(匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。）*

`\W`    ===> <b style="color:orange">同 [ ^A-Za-z0-9_] </b>  *(匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。)*

`\d`    ===>   <b style="color:orange">同 [0-9] </b> *(匹配任意阿拉伯数字。)*

`\D`    ===>   <b style="color:orange">同 [ ^0-9] </b> *(匹配任意一个不是阿拉伯数字的字符。)*

`x|y`  ===>  匹配`x`或`y`

`\s`    ===>  <b style="color:orange">同 [ \f\n\r\t\v] </b> *(匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。)*

`\S`    ===>   <b style="color:orange">同 [ ^ \f\n\r\t\v] </b>  *(匹配一个非空白符。)*

`\b`    ===>   *(<u>匹配一个零宽单词边界</u>)*

`\B`    ===>   *(匹配一个零宽非单词边界)*

`.`      ===>  *(点号，小数点) 匹配任意单个字符，但是行结束符除外：\n \r 。*

### 常用量词

`x*`    ===> *匹配前面的模式 x 0 或多次。*

`x+`    ===> *匹配前面的模式 x 1 或多次。*

`x?`    ===> *匹配前面的模式 x 0 或 1 次。*

`x{n} `        ===> *n 是一个正整数。前面的模式 x 连续出现 n 次时匹配。*

`x{n,m}`   ===>  *n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。*

`x{n,}`      ===>  *n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。*

### 举几个 :chestnut:

------
>ps 以下x表示某个字符      
#### /\s\w*/

```javascript
let re = /\s\w*/;
let text = 'xyz lm';
console.log(text.match(re));//["lm"]
```

> `\w*`匹配字母或_  0 或多次。

> `\s`匹配空格 `\w`匹配一个字符

------

#### /\S\w*/ 

```javascript
 let re2 = /\S\w*/;
 let text2 = 'xyz lm';
 console.log(text2.match(re2));//["xyz"]
```

> `\S\w*`匹配一个任意长度的非空白符

> `\S`匹配一个非空白符

------

#### /\bxxx/g  

```javascript
let re4 = /\bxyz/g;
let text4 = "xyz b xyz ";
console.log(text4.match(re4)); //["xyz","xyz"]
```

> `\b`匹配一个单词边界

> `g`匹配任意多次

------

#### /\bxxx\b/g  

```javascript
let re5 = /\bxyz\b/g;
let text5 = "axyz b xyz ";
console.log(text5.match(re5)); //["xyz"]
```

> `\bXXX\b`匹配单词的左右边界

------

#### /\Bxxx/g  

```javascript
let re6 = /\Bxyz/g;
let text6 = "axyz b cxyz";
console.log(text6.match(re6)); //["xyz","xyz"]
```

> `\B`匹配非单词边界

------


> ps:理解:fire:`\b`和`\B`的区别

`\b`以空格，标点分割字符串

`\B`以光标（鼠标光标）分割字符串

------
#### /\Bxxx\B/g  

```javascript
let re7 = /\Bxyz\B/g;
let text7 = "axyz b cxyzd";
console.log(text7.match(re7)); //["xyz"]
```

> `\BXXX\B`匹配左右非单词边界 他得到的结果必是某个字符串的子串

------
#### /x|y|z/g 

```javascript
let re = /xyz|a|[0-2]/g;
let text = "axyzbxa1221";
console.log(text.match(re)); //["a", "xyz", "a", "1", "2", "2", "1"]
```

> `|`匹配`x`或`y`或`z`

------

#### /\w/ 

```javascript
let re2 = /\w/;
let text2 = "apple";
console.log(text2.match(re2)); //["a"]
```

> `\w`匹配一个字母或_字符  同 [a-zA-Z0-9_]

------

#### /\W/

```javascript
let re3 = /\W/;
let text3 = "apple宇";
console.log(text3.match(re3)); //["宇"]
```

>匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。

------

#### /\d/

```javascript
let re4 = /\d/;
let text4 = "xyz1";
console.log(text4.match(re4)); //["1"]
```

> 匹配任意阿拉伯数字。
>

------

#### /\D/

```javascript
let re5 = /\D/;
let text5 = "xyz1";
console.log(text5.match(re5));  //["x"]
```

> 匹配任意一个不是阿拉伯数字的字符。

------

#### /.x/

```javascript
let re = /.y/;
let text = "yzxyzlm yz";
console.log(text.match(re)); //["xy"]
```

> `.` 匹配任意单个字符，但是行结束符除外：\n \r 。

------

#### /x*/

```javascript
let re = /x*/g;
let text = "xyz xlm";
console.log(text.match(re)); // ["x", "", "", "", "x", "", "", ""]
```

> `*`匹配前面的模式 x 0 或多次。

------

#### /x+/

```javascript
let re = /x+/g;
let text = "xyz xlm";
console.log(text.match(re)); // ["x", "x"]
```

> `+`匹配前面的模式 x 1 或多次。

------

#### /x?/

```javascript
let re = /x?/g;
let text = "xyzxx";
console.log(text.match(re)); // ["x", "", "", "x", "x", ""]
```

>`?`匹配前面的模式 x 0 或 1 次。

------

#### /x{n}/

```javascript
let re2 = /x{2}/g;
let text2 = "xyz xxxx xl xx";
console.log(text2.match(re2)); //["xx", "xx", "xx"]
```

> `{n} `          n 是一个正整数。前面的模式 x 连续出现 n 次时匹配。

------

#### /x{n,m}/

```javascript
let re3 = /x{1,3}/g;
let text3 = "xyz xxylmxxxlxxxxx";
console.log(text3.match(re3)); //["x", "xx", "xxx", "xxx", "xx"]
```

> `{n,m} `      n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。

------

#### /x{n,}/

```javascript
let re4 = /x{2,}/g;
let text4 = "xyz xxylmxxxlxxxxx";
console.log(text4.match(re4)); //["xx", "xxx", "xxxxx"]
```

> `{n,} `         n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。

