# HTTP缓存

![](https://tva1.sinaimg.cn/large/008i3skNly1gwydmfqe3rj30vu0fcgmx.jpg)
### 什么是浏览器缓存？

浏览器缓存是指的  **web资源的副本** 。 

当浏览器向服务器请求资源时，若是相同的url，浏览器会根据缓存机制决定是使用副本来响应访问请求，还是向源服务器再次发送请求。

### 为什么需要浏览器缓存 ？

- 减少网络延迟，加快页面打开速度
- 减少网络带宽消耗
- 降低服务压力



### HTTP缓存机制

#### 简化流程如下

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvv5o8vut1j30jj0d6q38.jpg" style="zoom:75%;" />

#### 缓存规则

1、新鲜度(过期机制):一个缓存副本的有效期。一个缓存副本满足以下性质时，我们认为他是新鲜的

- 含有完整的过期时间控制头信息(HTTP协议报头)，并且仍在有效期内；
- 浏览器已经使用过这个副本，并且在一个会话中已经检查过新鲜度；

2、校验值(验证机制):服务器返回资源的时候。有时会在控制头信息带上这个资源的实体标签Etag,他可以用来作为浏览器再次请求过程的校验标志。如果发现校验标志不匹配，说明资源已经被修改或过期，浏览器就会重新获取资源内容。



### HTTP缓存的两个阶段

- 强缓存(本地缓存)
- 弱缓存(协商缓存)

#### 强缓存

浏览器发送请求前，会先去缓存里查看是否命中强缓存，如果命中，则直接从缓存中读取资源，不会发送请求到服务器。否则，就会进入协商缓存阶段。

#### 弱缓存(协商缓存)

当强缓存没有命中的时，浏览器会向服务器发起请求。服务器会根据请求头中携带的字段；来判断是否命中协商缓存。如果命中，服务器会下发304响应（不携带任何实体信息），告诉服务器可以直接从浏览器缓存中获取这个信息。但是如果强弱缓存都没有命中的话，就会直接从服务器加载资源。

#### 启用&关闭缓存

按照本地缓存和协商缓存可以将控制缓存的方式分为

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwbcjeoqzjj30t90hnjs1.jpg" style="zoom:50%;" />

#### 强缓存过程

浏览器中的缓存分为两种情况

- 需要发送http请求
- 不需要发送http请求

首先是检查本地强缓存,这个阶段不需要进行http请求

浏览器会检查http中的字段，

在HTTP/1.0中使用`Expires`字段

在HTTP/1.1中使用`Cache-Control`字段

##### Expires

过期时间，存在服务端返回的响应头里，告诉浏览器在这个过期时间内可以直接从缓存里面获取数据。

```
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

但是这个方法存在问题，就是浏览器的时间可能跟服务器的时间不一致(时区)，所以时间可能不准确，所以在后面的HTTP/1.1中被放弃使用（但是还存在）。

##### cache-control

他有许多的字段在操控缓存

比如不再使用具体的过期时间点,采用过期时长来控制缓存，对应的字段为`max-age`

```
Cache-Control:max-age=3600
```

这个代表3600s之内，可以直接直接使用缓存。

除此之外他还有更多灵活的配置，

`private:`只有浏览器可以缓存。中间经过的代理服务器不可以缓存。

`no-cache:`不进行本地的缓存，直接进入协商缓存。

`no-store:`不进行任何形式的缓存。每一次都从浏览器获取。

`s-maxage:`针对代理服务器的缓存。

这时候如果设置的缓存时间超时，就会进入协商缓存。

#### 协商缓存过程

强缓存失败后，浏览器会在请求中携带`缓存tag`来向服务器发送请求，由服务器根据这个tag来决定是否使用缓存，这就是协商缓存。

**缓存tag**分为两种:`Last-Modified`和`ETag`。

##### Last-Modified

最后修改时间，在浏览器向服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，如果再次请求，就会在请求头中携带`IF-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

服务器在拿到`IF-Modified-Since`字段后,会和服务器内的`该资源的最后修改时间做对比`(因为资源的源代码是在服务器上的，开发者修改资源的内容的时间就是该时间)

如果浏览器发来的`IF-Modified-Since`的时间小于服务器中。就说明资源需要更新,就会走正常的HTTP响应请求。

否则返回304，告诉浏览器直接是用缓存。

##### ETag

`ETag`是服务器根据当前文件的内容，给文件生成一个唯一的标识，只要里面的内容改动，这个值就会改变。同时服务器会通过`响应头`把这个值给服务器。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwpd1f199rj30i401a3yf.jpg" style="zoom:50%;" />

浏览器接收到`ETag`的值后，会在下一次请求时，将这个值作为`if-None-Match`这个字段的内容，并放到请求头中，然后发给服务器。

服务器接受到`if-None-Match`值后，会跟服务器上该资源的`ETag`进行比较：

- 不一样，就更新
- 一样，就304，告诉浏览器直接用缓存。

##### 两者对比

1、在`精准度`上，`ETag`优于`Last-Modified`。因为ETag是和内容密切相关的，但是Last-modified并不能准确的感知资源的变化，主要有两种情况。

- 编辑了资源文件，但是文件的内容没有更改，这样也会造成缓存失败。
- last-modified感知的时间单位是秒，文件在1秒内改变了多次，那这个时候last-modified就不能体现出来修改了

2、`性能上`last-modified优于ETag，因为ETag还需要计算资源的hash（哈希）。

值得注意的是，两种方式都支持的话，服务器会优先考虑ETag



#### 缓存的位置

当命中`强缓存`命中或者协商缓存中服务器返回304时，我们会直接从缓存中获取资源。

浏览器中的缓存位置一共有四种，按优先级从高到低可以分为

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

##### Service Worker

Service Worker借鉴了Web worker的思路，既让JS运行在主线程之外，由于他脱离了浏览器的窗体，因此无法访问DOM。虽然如此，但是他仍能帮我们完成很多有用的功能，比如`离线缓存`、`消息推送`、`网络代理`。其中离线缓存就是`service Worker Cache`。

Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。

> PWA(渐进式web应用)



##### Memory Cache 和 Disk Cache

Memory Cache指的是内存缓存。当渲染进程结束之后，内存缓存就会被清除。

Disk Cache 指的是磁盘缓存。储存效率比内存缓存低，但是容量大和缓存时间长。

浏览器的缓存策略:

- 内存大的JS文件、css文件会直接被丢入磁盘。
- 内存使用率较高时，文件优先进入磁盘。

##### Push Cache

Push Cache (推送缓存)是HTTP/2中的内容，当以上三种缓存都没有命中时，他才会被使用，他只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂。在google中只存在5分钟。

- 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差
- 可以推送 no-cache 和 no-store 的资源
- 一旦连接被关闭，Push Cache 就被释放
- 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 你可以给其他域名推送资源

如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。

# ref

[浏览器缓存详解](https://hddhyq.github.io/2020/04/26/browser-cache-control/)



























